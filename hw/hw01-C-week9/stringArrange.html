<!DOCTYPE html>
<html>
<head>
<title>stringArrange.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!--
 * @Author: Frank Chu
 * @Date: 2022-11-03 11:13:57
 * @LastEditors: Frank Chu
 * @LastEditTime: 2022-11-03 13:09:46
 * @FilePath: /Cpp/hw/hw01-C-week9/stringArrange.md
 * @Description: 
 * 
 * Copyright (c) 2022 by Frank Chu, All Rights Reserved. 
-->
<h1 id="string--characters-in-c">String &amp; Characters in C</h1>
<h2 id="difference-in-explicit">Difference in explicit</h2>
<p><a href="https://www.geeksforgeeks.org/difference-between-scanf-and-gets-in-c/">GeeksForGeeks - Difference between <code>scanf()</code> and <code>gets()</code> in C</a></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{

    <span class="hljs-comment">// Reads the next character from stdin.</span>
    <span class="hljs-keyword">int</span> ch;
    <span class="hljs-comment">/* read/print "abcde" from stdin */</span>
    <span class="hljs-keyword">while</span> ((ch=getchar()) != EOF)
          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, ch);

    <span class="hljs-comment">// Reads stdin into the character array pointed to by str </span>
    <span class="hljs-comment">// until a newline character is found or end-of-file occurs.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// It is used to read input from the standard input(keyboard).</span>
    <span class="hljs-comment">// It is used to read the input until it encounters newline or End Of File(EOF).</span>
    <span class="hljs-keyword">char</span> stringToBeCutted[<span class="hljs-number">105</span>];
    <span class="hljs-keyword">while</span> (gets(stringToBeCutted) != <span class="hljs-literal">NULL</span>) { }

    <span class="hljs-comment">// Reads data from a variety of sources, </span>
    <span class="hljs-comment">// interprets it according to format and stores the results into given location.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// It is used to read the input(character, string, numeric data) from the standard input(keyboard).</span>
    <span class="hljs-comment">// It is used to read the input until it encounters a whitespace, newline or End Of File(EOF).</span>
    <span class="hljs-keyword">int</span> a;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a);
}
</div></code></pre>
<h2 id="getchar">getchar</h2>
<p><a href="https://en.cppreference.com/w/c/io/getchar">cppreference.com - getchar</a></p>
<p>Defined in header &lt;stdio.h&gt;</p>
<p><code>int getchar(void);</code></p>
<p>Reads the next character from stdin.</p>
<p>Equivalent to <code>getc(stdin)</code>.</p>
<h3 id="parameters">Parameters</h3>
<p>None</p>
<h3 id="return-value">Return value</h3>
<p>The obtained character on success or EOF on failure.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{ 
    <span class="hljs-keyword">int</span> ch;
    <span class="hljs-keyword">while</span> ((ch=getchar()) != EOF)   <span class="hljs-comment">/* read/print "abcde" from stdin */</span>
          <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>, ch);
}
</div></code></pre>
<h2 id="gets">gets</h2>
<p><a href="https://en.cppreference.com/w/c/io/gets">cppreference.com - gets</a></p>
<p>Defined in header &lt;stdio.h&gt;</p>
<p><code>char *gets( char *str );</code> (<a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">removed in C11</a>)</p>
<p><code>char *gets_s( char *str, rsize_t n);</code> (Since C11)</p>
<ol>
<li>Reads stdin into the character array pointed to by str until a newline character is found or end-of-file occurs. A null character is written immediately after the last character read into the array. <strong>The newline character is discarded but not stored in the buffer</strong>.</li>
</ol>
<h3 id="parameters-for-gets">Parameters for gets</h3>
<p>str - character string to be written</p>
<h3 id="return-value-for-gets">Return value for gets</h3>
<p>str on success, a numm pointer on failure.</p>
<h3 id="notes">Notes</h3>
<p>The <code>gets()</code> function does not perform bounds checking, therefore this function is extremely vulnerable to buffer-overflow attacks. It cannot be used safely. For this reason, <strong>the function has been deprecated in the third corrigendum to the C99 standard and removed altogether in the C11 standard</strong>. <code>fgets()</code> and <code>gets_s()</code> are the recommended replacements.</p>
<p><strong>Never use gets().</strong></p>
<h2 id="scanf">scanf</h2>
<p>Defined in header &lt;stdio.h&gt;</p>
<p><code>int scanf( const char          *format, ...);</code> until C99</p>
<p><code>int scanf( const char *restrict format, ...);</code> since C99</p>
<p>Reads data from a variety of sources, interprets it according to format and stores the results into given location.</p>
<p>reads the data from stdin</p>
<h3 id="parameters-for-scanf">Parameters for scanf</h3>
<ul>
<li>stream - input file stream to read from</li>
<li>buffer - pointer to a null-terminated character string to read from</li>
<li>format - pointer to a null-terminated character string specifying how to read the input</li>
<li>... - receiving arguments.</li>
</ul>
<p>The format string consists of:</p>
<ul>
<li>non-whitespace multibyte characters except <code>%</code>: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</li>
<li>whitespace characters: any single whitespace character in the format string consumes all available consecutive whitespace characters from the input (determined as if by calling isspace in a loop). Note that there is no difference between <code>&quot;\n&quot;</code>, <code>&quot; &quot;</code>, <code>&quot;\t\t&quot;</code>, or other whitespace in the format string.</li>
<li>conversion specificatitons. Each conversion specification has the following format:
<ul>
<li>introductory <code>%</code> character</li>
<li>(optional) assignment-suppressing character <code>*</code>.</li>
<li>(optional) integer number(greater than zero) that specifies maximum field width.</li>
<li>(optional) length modifier that specifies the size of the receiving argument, that is, the actual destination type.</li>
<li>conversion format specifier</li>
</ul>
</li>
</ul>
<p>The following format specifiers are available:</p>
<table>
<thead>
<tr>
<th>Conversion specifier</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>matches a decimal integer.</td>
</tr>
<tr>
<td>i</td>
<td>matches an integer.</td>
</tr>
<tr>
<td>f</td>
<td>matches a floating-point number.</td>
</tr>
</tbody>
</table>
<h3 id="notes-for-scanf">Notes for scanf</h3>
<p>Because most conversion specifiers first consume all consecutive whitespace, code such as</p>
<pre class="hljs"><code><div><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a);
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;b);
</div></code></pre>
<p>will read two integers that are entered on different lines (second <code>%d</code> will consume the newline left over by the first) or on the same line, separated by spaces or tabs (second <code>%d</code> will consume the spaces or tabs).</p>
<p>The conversion specifiers that do not consume leading whitespace, such as <code>%c</code> can be made to do so by using a whitespace character in the format string:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a);
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">" %c"</span>, &amp;c); <span class="hljs-comment">// consume all consecutive whitespace after %d, then read a char</span>
</div></code></pre>

</body>
</html>
